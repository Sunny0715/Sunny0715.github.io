<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[spring aop两种配置方式]]></title>
      <url>%2F2017%2F09%2F12%2Fspring-aop%E4%B8%A4%E7%A7%8D%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[前言AOPAOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。 使用”横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事务。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。 AOP核心概念1、横切关注点 对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点 2、切面（Aspect） 类是对物体特征的抽象，切面就是对横切关注点的抽象 3、连接点（Joinpoint） 被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器 4、切入点（Pointcut） 对连接点进行拦截的定义 5、通知（Advice） 所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类 6、目标对象 代理的目标对象 7、织入（Weave） 将切面应用到目标对象并导致代理对象创建的过程 8、引入（Introduction） 在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段 Spring对AOP的支持Spring中AOP代理由Spring的IOC容器负责生成、管理，其依赖关系也由IOC容器负责管理。因此，AOP代理可以直接使用容器中的其它bean实例作为目标，这种关系可由IOC容器的依赖注入提供。Spring创建代理的规则为： 1、默认使用Java动态代理来创建AOP代理，这样就可以为任何接口实例创建代理了 2、当需要代理的类不是代理接口的时候，Spring会切换为使用CGLIB代理，也可强制使用CGLIB AOP编程其实是很简单的事情，纵观AOP编程，程序员只需要参与三个部分： 1、定义普通业务组件 2、定义切入点，一个切入点可能横切多个业务组件 3、定义增强处理，增强处理就是在AOP框架为普通业务组件织入的处理动作 所以进行AOP编程的关键就是定义切入点和定义增强处理，一旦定义了合适的切入点和增强处理，AOP框架将自动生成AOP代理，即：代理对象的方法=增强处理+被代理对象的方法。 Spring配置AOP的两种方式注解配置AOP注解配置AOP（使用 AspectJ 类库实现的），大致分为三步： 使用注解@Aspect来定义一个切面，在切面中定义切入点(@Pointcut),通知类型(@Before, @AfterReturning,@After,@AfterThrowing,@Around). 开发需要被拦截的类。 将切面配置到xml中，当然，我们也可以使用自动扫描Bean的方式。这样的话，那就交由Spring AOP容器管理。 applicationContext的配置 12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;!-- 激活组件扫描功能,在包com.spring.aop及其子包下面自动扫描通过注解配置的组件 --&gt; &lt;context:component-scan base-package="com.spring.aop"/&gt; &lt;!-- 激活自动代理功能 --&gt; &lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt; &lt;context:annotation-config /&gt; &lt;!-- 用户服务对象 --&gt; &lt;bean id="userService" class="com.spring.aop.service.UserService" /&gt;&lt;/beans&gt; 为Aspect切面类添加注解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.spring.aop.aspect;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.AfterThrowing;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;/** * 系统服务组件Aspect切面Bean *///声明这是一个组件@Component//声明这是一个切面Bean@Aspectpublic class ServiceAspect &#123; private final static Log log = LogFactory.getLog(ServiceAspect.class); //配置切入点,该方法无方法体,主要为方便同类中其他方法使用此处配置的切入点 @Pointcut("execution(* com.spring.aop.service..*(..))") public void aspect()&#123; &#125; /* * 配置前置通知,使用在方法aspect()上注册的切入点 * 同时接受JoinPoint切入点对象,可以没有该参数 */ @Before("aspect()") public void before(JoinPoint joinPoint)&#123; if(log.isInfoEnabled())&#123; log.info("before " + joinPoint); &#125; &#125; //配置后置通知,使用在方法aspect()上注册的切入点 @After("aspect()") public void after(JoinPoint joinPoint)&#123; if(log.isInfoEnabled())&#123; log.info("after " + joinPoint); &#125; &#125; //配置环绕通知,使用在方法aspect()上注册的切入点 @Around("aspect()") public void around(JoinPoint joinPoint)&#123; long start = System.currentTimeMillis(); try &#123; ((ProceedingJoinPoint) joinPoint).proceed(); long end = System.currentTimeMillis(); if(log.isInfoEnabled())&#123; log.info("around " + joinPoint + "\tUse time : " + (end - start) + " ms!"); &#125; &#125; catch (Throwable e) &#123; long end = System.currentTimeMillis(); if(log.isInfoEnabled())&#123; log.info("around " + joinPoint + "\tUse time : " + (end - start) + " ms with exception : " + e.getMessage()); &#125; &#125; &#125; //配置后置返回通知,使用在方法aspect()上注册的切入点 @AfterReturning("aspect()") public void afterReturn(JoinPoint joinPoint)&#123; if(log.isInfoEnabled())&#123; log.info("afterReturn " + joinPoint); &#125; &#125; //配置抛出异常后通知,使用在方法aspect()上注册的切入点 @AfterThrowing(pointcut="aspect()", throwing="ex") public void afterThrow(JoinPoint joinPoint, Exception ex)&#123; if(log.isInfoEnabled())&#123; log.info("afterThrow " + joinPoint + "\t" + ex.getMessage()); &#125; &#125; &#125; 测试代码 12345678910111213141516171819202122232425262728293031323334package com.spring.aop;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.spring.aop.service.UserService;import com.spring.mvc.bean.User;/** * Spring AOP测试 */public class Tester &#123; private final static Log log = LogFactory.getLog(Tester.class); public static void main(String[] args) &#123; //启动Spring容器 ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml"); //获取service组件 UserService service = (UserService) context.getBean("userService"); //以普通的方式调用UserService对象的三个方法 User user = service.get(1L); service.save(user); try &#123; service.delete(1L); &#125; catch (Exception e) &#123; if(log.isWarnEnabled())&#123; log.warn("Delete user : " + e.getMessage()); &#125; &#125; &#125;&#125; 控制台输出如下： 12345678910111213141516INFO [spring.aop.aspect.ServiceAspect:40] before execution(User com.spring.aop.service.UserService.get(long))INFO [spring.aop.service.UserService:19] getUser method . . .INFO [spring.aop.aspect.ServiceAspect:60] around execution(User com.spring.aop.service.UserService.get(long)) Use time : 42 ms!INFO [spring.aop.aspect.ServiceAspect:48] after execution(User com.spring.aop.service.UserService.get(long))INFO [spring.aop.aspect.ServiceAspect:74] afterReturn execution(User com.spring.aop.service.UserService.get(long))INFO [spring.aop.aspect.ServiceAspect:40] before execution(void com.spring.aop.service.UserService.save(User))INFO [spring.aop.service.UserService:26] saveUser method . . .INFO [spring.aop.aspect.ServiceAspect:60] around execution(void com.spring.aop.service.UserService.save(User)) Use time : 2 ms!INFO [spring.aop.aspect.ServiceAspect:48] after execution(void com.spring.aop.service.UserService.save(User))INFO [spring.aop.aspect.ServiceAspect:74] afterReturn execution(void com.spring.aop.service.UserService.save(User))INFO [spring.aop.aspect.ServiceAspect:40] before execution(boolean com.spring.aop.service.UserService.delete(long))INFO [spring.aop.service.UserService:32] delete method . . .INFO [spring.aop.aspect.ServiceAspect:65] around execution(boolean com.spring.aop.service.UserService.delete(long)) Use time : 5 ms with exception : spring aop ThrowAdvice演示INFO [spring.aop.aspect.ServiceAspect:48] after execution(boolean com.spring.aop.service.UserService.delete(long))INFO [spring.aop.aspect.ServiceAspect:74] afterReturn execution(boolean com.spring.aop.service.UserService.delete(long))WARN [studio.spring.aop.Tester:32] Delete user : Null return value from advice does not match primitive return type for: public boolean com.spring.aop.service.UserService.delete(long) throws java.lang.Exception 可以看到，正如我们预期的那样，虽然我们并没有对UserSerivce类包括其调用方式做任何改变，但是Spring仍然拦截到了其中方法的调用，或许这正是AOP的魔力所在。 XML配置AOPXML配置 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;!-- 系统服务组件的切面Bean --&gt; &lt;bean id="serviceAspect" class="com.spring.aop.aspect.ServiceAspect"/&gt; &lt;!-- AOP配置 --&gt; &lt;aop:config&gt; &lt;!-- 声明一个切面,并注入切面Bean,相当于@Aspect --&gt; &lt;aop:aspect id="simpleAspect" ref="serviceAspect"&gt; &lt;!-- 配置一个切入点,相当于@Pointcut --&gt; &lt;aop:pointcut expression="execution(* com.spring.aop.service..*(..))" id="simplePointcut"/&gt; &lt;!-- 配置通知,相当于@Before、@After、@AfterReturn、@Around、@AfterThrowing --&gt; &lt;aop:before pointcut-ref="simplePointcut" method="before"/&gt; &lt;aop:after pointcut-ref="simplePointcut" method="after"/&gt; &lt;aop:after-returning pointcut-ref="simplePointcut" method="afterReturn"/&gt; &lt;aop:after-throwing pointcut-ref="simplePointcut" method="afterThrow" throwing="ex"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; ServiceAspect.java 1234567891011121314151617181920212223//配置前置通知,拦截返回值为com.spring.mvc.bean.User的方法@Before("execution(com.spring.mvc.bean.User com.spring.aop.service..*(..))")public void beforeReturnUser(JoinPoint joinPoint)&#123; if(log.isInfoEnabled())&#123; log.info("beforeReturnUser " + joinPoint); &#125;&#125;//配置前置通知,拦截参数为com.spring.mvc.bean.User的方法@Before("execution(* com.spring.aop.service..*(com.spring.mvc.bean.User))")public void beforeArgUser(JoinPoint joinPoint)&#123; if(log.isInfoEnabled())&#123; log.info("beforeArgUser " + joinPoint); &#125;&#125;//配置前置通知,拦截含有long类型参数的方法,并将参数值注入到当前方法的形参id中@Before("aspect()&amp;&amp;args(id)")public void beforeArgId(JoinPoint joinPoint, long id)&#123; if(log.isInfoEnabled())&#123; log.info("beforeArgId " + joinPoint + "\tID:" + id); &#125;&#125; UserService.java 123456789101112131415161718192021222324252627282930313233343536package com.spring.aop.service;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import com.spring.mvc.bean.User;/** * 用户服务模型 */public class UserService &#123; private final static Log log = LogFactory.getLog(UserService.class); public User get(long id)&#123; if(log.isInfoEnabled())&#123; log.info("getUser method . . ."); &#125; return new User(); &#125; public void save(User user)&#123; if(log.isInfoEnabled())&#123; log.info("saveUser method . . ."); &#125; &#125; public boolean delete(long id) throws Exception&#123; if(log.isInfoEnabled())&#123; log.info("delete method . . ."); throw new Exception("spring aop ThrowAdvice演示"); &#125; return false; &#125; &#125; 总结SpringAop可以用来： Spring声明式事务管理配置。 在执行方法前,判断是否具有权限。 对部分函数的调用进行日志记录。监控部分重要函数，若抛出指定的异常，可以以短信或邮件方式通知相关人员。 使用Spring AOP实现MySQL数据库读写分离。 信息过滤 ……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[跨页面(Tab/Window)通信的几种方法]]></title>
      <url>%2F2017%2F09%2F01%2F%E8%B7%A8%E9%A1%B5%E9%9D%A2-Tab-Window-%E9%80%9A%E4%BF%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[​ 今天开发一个功能遇到一个需求，在A页面点击查看详情后打开B页面进行修改或删除，删除后B页面关闭，然后刷新A页面里面的数据。相当于就是两个页面之间进行通讯，作为后端的我第一想法是利用webSocket 进行通讯，之后通过谷歌和百度找出了更为简便的方法。 利用webSocket进行通讯​ 第一想法是这个，但是这样的话工作量巨大而且还需要后端支持，太麻烦了，对于我这种懒人直接就放弃了，去寻找有没有更简便的方法。 定时器不断检查cookies变化在stackoverflow上看到一个方案，大致思路是： 在页面A设置一个使用 setInterval 定时器不断刷新，检查 Cookies 的值是否发生变化，如果变化就进行刷新的操作。 由于 Cookies 是在同域可读的，所以在页面 B 审核的时候改变 Cookies 的值，页面 A 自然是可以拿到的。这样做确实可以实现我想要的功能，但是这样的方法相当浪费资源。虽然在这个性能过盛的时代，浪费不浪费也感觉不出来，但是这种实现方案，确实不够优(zhuāng)雅（bī）。 localStorage的事件功夫不负有心人，后来发现 window 有一个 StorageEvent ，每当 localStorage 改变的时候可以触发这个事件。（这个原理就像你给一个DOM 绑定了 click 事件，当你点击它的时候，就会自动触发。）也就是说，我给 window 绑定这个事件后，每当我改变 localStorage 的时候，他都会触发这个事件。 123window.addEventListener(&apos;storage&apos;, function (event) &#123; console.log(event);&#125;); 这个回调中的event与普通的EVNET,基本差不多，但是它比其他的event多了如下几个属性: 属性 描述 key 受影响的 localStorage 的 key newValue 新的值 oldValue 旧的值 url 触发此事件的url 每当一个页面改变了 localStorage 的值，都会触发这个事件。也就是说可以很容易的通过改变 localStorage 的值，来实现浏览器中跨页面( tab / window )之间的通讯。记住这个事件只有在 localStorage 发生改变的时候才会被触发，如果没改变则不会触发此事件。 123localStorage.setItem(&apos;delete&apos;,1); //触发localStorage.setItem(&apos;delete&apos;,1); //不触发localStorage.setItem(&apos;delete&apos;,2); //触发 在使用的时候务必注意这一点。最终实现代码: 页面A： 123456//页面 Awindow.addEventListener(&apos;storage&apos;, function (event) &#123; if(event.key === &apos;delete_verify_list&apos;)&#123; //页面操作 &#125;&#125;); 页面B： 1234567891011121314//页面 B/** * 获取一个随机id * @return &#123;String&#125; - 返回一个5位的随机字符串 */function randomId() &#123; return (Math.random() * 1E18).toString(36).slice(0, 5).toUpperCase();&#125;//每当需要页面A更新时 执行此方法if (localStorage) &#123; //为保证每次页面A都执行，此处我设置里一个随机字符串 localStorage.setItem(&apos;delete_verify_list&apos;, randomId());&#125; 参考：https://ponyfoo.com/articles/cross-tab-communication]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JAVA实现HTML转PDF]]></title>
      <url>%2F2017%2F07%2F27%2FJAVA%E5%AE%9E%E7%8E%B0HTML%E8%BD%ACPDF%2F</url>
      <content type="text"><![CDATA[​ 最近公司里面有一个任务，在线题卡，就是把客户在线编辑的题卡样式保存下来，然后可以导出为PDF格式。于是上网找了一系列的资料，找到了以下两种方法： 使用wkhtmltox 使用iText+Flying Saucer 但是还是强烈推荐用第一种方法。 使用wkhtmltox(推荐)wkhtmltox实现网页转换成图片或PDF 命令实现 进入wkhtmltox官网软件下载 ：https://wkhtmltopdf.org/downloads.html 安装完成后进入${home}/bin目录下有两个exe文件，通过名称就可以辨别wkhtmltoimage.exe是将HTML转化为image，wkhtmltopdf.exe是将HTML转化为PDF文件，这正是我们想要的。 进入${home}/bin目录下打开cmd输入以下命令验证 12wkhtmltopdf HTML路径 保存路径如： wkhtmltopdf www.baidu.com d:\test.pdf 生成完成后会出现Done。 代码实现JAVA代码中调用wkhtmltopdf生成PDF文件，以下为代码片段 1234567891011121314151617181920212223242526272829303132333435363738/** * HTMLTOPPDF * 利用wkhtmltopdf生成PDF */public class HtmlToPDF &#123; //wkhtmltopdf.exe安装路径 public static final String toPdfTool = "E:\\SmallTools\\wkhtmltox\\wkhtmltopdf\\bin\\wkhtmltopdf.exe"; //需要生成PDF的URL public static final String srcPath = "http://www.jianshu.com/p/4d65857ffe5e"; public static void main(String[] args) throws Exception&#123; //设置纸张大小: A4, Letter, etc. String pageSize = "A4"; //生成后存放路径 String destPath = "E:\\PDF生成教程及讲解.pdf"; convert(pageSize, destPath); &#125; public static void convert(String pageSize, String destPath)&#123; File file = new File(destPath); File parent = file.getParentFile(); if (!parent.exists())&#123; parent.mkdirs(); &#125; StringBuilder cmd = new StringBuilder(); cmd.append(toPdfTool).append(" "); cmd.append("--page-size "); cmd.append(pageSize).append(" "); cmd.append(srcPath).append(" "); cmd.append(destPath); try &#123; Runtime.getRuntime().exec(cmd.toString()); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 详细参数说明可参考：http://www.jianshu.com/p/4d65857ffe5e 使用iText+Flying Saucer123456789itext可实现 1.可以进行块的创建2.表格的使用3.设置页面的事件4.字体的设置5.图片的设置（包含水印）6.HTML转化成PDF（支持css,javascript）7.表单创建8.PDF之间的操作等详细的内容可以查看网站的说明。 Maven配置12345678910&lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itextpdf&lt;/artifactId&gt; &lt;version&gt;5.8.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.xhtmlrenderer&lt;/groupId&gt; &lt;artifactId&gt;flying-saucer-pdf&lt;/artifactId&gt; &lt;version&gt;9.1.6&lt;/version&gt;&lt;/dependency&gt; 代码片段1234567891011121314151617181920212223/** * 生成pdf，添加生成pdf所使用的字符集.注：这里字符集要和模板中使用的字符集一一致。 */public class HtmlToPDF &#123; public static void main(String[] args) throws Exception&#123; Document document = new Document(PageSize.A4.rotate()); //设置为A4纸大小 ITextRenderer renderer = new ITextRenderer(); ITextFontResolver fontResolver = renderer.getFontResolver(); fontResolver.addFont("D:/simsun.ttc", BaseFont.IDENTITY_H, BaseFont.NOT_EMBEDDED); // step 2 PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream("D:\\pdf.pdf")); // step 3 document.open(); // step 4 XMLWorkerHelper.getInstance().parseXHtml(writer, document, new FileInputStream("D:/a.html")); //step 5 document.close(); System.out.println( "PDF Created!" ); &#125;&#125; 注意事项 .输入的HTML页面必须是标准的XHTML页面。页面的顶上必须是这样的格式： 12&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; 生成PDF，添加生成PDF所使用的字符集.注：这里字符集要和模板中使用的字符集一一致。 比如:java中使用宋体 renderer.getFontResolver().addFont(“C:/Windows/Fonts/simsun.ttc”, BaseFont.IDENTITY_H, BaseFont.NOT_EMBEDDED); 那么HTML的body中样式必须加上 style=’font-family:SimSun’，要是使用其他字符生成pdf时候，中文就会不显示生成PDF 设置PDF的页面大小模板页面中添加该样式：@page { size: 8.5in 11in; }这时候生成PDF页面正好是A4纸大小 所需的jar包，下载点我。核心jar是修改后的 比较和总结比较itext 1231. java生成PDF大部分都是用itext，itext的确是java开源组件的第一选择。不过itext也有局限，就是要自己写模版，系统中的表单数量有好几百个，为每个表单做一个导出模版不现实。2. 并且itext中文适配不是很好和换行问题。3. 且对HTML格式要求严格。 wkhtmltopdf 1231. 生成PDF时会自动根据你在HTML页面中H标签生成树形目录结构。2. 小巧方便，转换速度快。3. 跨平台，在Liunx下用，在win下也可以用。 总结​ 综上比较，wkhtmltopdf是将HTML转为图片或是PDF最好的选择。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[微信公众号网页开发]]></title>
      <url>%2F2017%2F06%2F01%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%BD%91%E9%A1%B5%E5%BC%80%E5%8F%91%2F</url>
      <content type="text"><![CDATA[前言最近一直参与公司开发公众号，关于项目实施平台PC端简化为微信公众号，主要架构为前台H5，使用时的微信的WeUI的SDK，后台就是现在流行的SpringMVC+Mybaties，参与了全程开发，开发过程中也遇到了不少的问题，现在记录下来，希望以后能够用得到。 HTML页面之间传值JSP之间传值已经很熟悉，HTML之间传值是通过解析URL获取所需参数。 12//URL传值URL + "?logId=" + logId; 12345678910111213141516171819202122232425262728//获取所需参数var hrefInfo = getUrlVars(window.location.href); if (hrefInfo.logId &amp;&amp; hrefInfo.logId != "undefined") &#123; fillData(hrefInfo.logId); logId = hrefInfo.logId; &#125; else &#123;&#125;// 得到url中的参数function getUrlVars(hrf) &#123; var vars = [], hash; var locationHref = !hrf ? window.location.href : hrf; locationHref = locationHref.replace(/#/g, ""); if (locationHref.indexOf('%') &gt; 0) &#123; locationHref = unescape(locationHref); &#125; var hashes = locationHref.slice(locationHref.indexOf('?') + 1).split('&amp;'); for ( var i = 0; i &lt; hashes.length; i++) &#123; hash = hashes[i].split('='); vars.push(hash[0]); vars[hash[0]] = hash[1]; &#125; return vars;&#125; JS、JQuery获取各种屏幕的高度和宽度在移动端经常会用到获取屏幕的高度和宽度，在这里总结一下。 12345678910111213Javascript:document.body.clientWidth //网页可见区域宽document.body.clientHeight //网页可见区域高document.body.offsetWidth (包括边线的宽) //网页可见区域宽document.body.offsetHeight (包括边线的高) //网页可见区域高document.body.scrollWidth //网页正文全文宽document.body.scrollHeight //网页正文全文高document.body.scrollTop //网页被卷去的高document.body.scrollLeft //网页被卷去的左window.screenTop //网页正文部分上window.screen.width //屏幕分辨率的宽window.screen.availHeight //屏幕可用工作区高度window.screen.availWidth //屏幕可用工作区宽度 123456789101112JQuery:$(document).ready(function()&#123;alert($(window).height()); //浏览器当前窗口可视区域高度alert($(document).height()); //浏览器当前窗口文档的高度alert($(document.body).height()); //浏览器当前窗口文档body的高度alert($(document.body).outerHeight(true));//浏览器当前窗口文档body的总高度 包括border padding marginalert($(window).width()); //浏览器当前窗口可视区域宽度alert($(document).width()); //浏览器当前窗口文档对象宽度alert($(document.body).width()); //浏览器当前窗口文档body的宽度alert($(document.body).outerWidth(true));//浏览器当前窗口文档body的总宽度 包括border padding margin&#125;) 微信浏览器缓存清理微信浏览器缓存一直都是相当恶心的存在，只要页面加载，那么静态页面就会被缓存，通过Google和百度找到了以下两种方法： 设置HTTP头部通过这只HTTP头部禁止浏览器缓存，效果没有达到要求，不建议使用 Android下可在微信中打开http://debugx5.qq.com清除微信缓存。 1234567891011&lt;html manifest="IGNORE.manifest"&gt; &lt;meta charset="utf-8"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;&lt;meta http-equiv="pragma" content="no-cache"&gt;&lt;meta http-equiv="cache-control" content="no-cache"&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"&gt;&lt;link rel="shortcut icon" href="../../view/images/favicon.ico" type="image/x-icon" /&gt; 更新版本号HTTP头部禁止缓存不能用，就只能每次都更新版本号(加随机数)来达到自己的要求了。 使用SeaJs拦截所有.js和.css并在尾部加上随机数。 引入SeaJs1&lt;script src="../../util/sea.js"&gt;&lt;/script&gt; 配置seajs_config.js 需要配置seajs_config.js全局变量，每一个HTML页面都要引入，关于更多SeaJs配置http://yslove.net/seajs/ 1234567891011var time = new Date().getTime();var sea_config = &#123; "base":"/", //web发布路径 "debug":"true", //2:每次从后台获取新的js,true:console出bug,false:默认 "charset":"utf-8", //字符集 preload: ["util/jquery-1.8.0.min.js"], //预加载jquery map: [ //配置映射，用来版本更新强制浏览器刷新 ['.js','.js?version=' + time], ['.css','.css?version=' + time] ]&#125;; 12345//HTML页面引入&lt;script src="../../config/seaConfig/seajs_config.js"&gt;&lt;/script&gt;&lt;script&gt; seajs.config(sea_config);&lt;/script&gt; Ajax请求缓存 在编码期间，因为有个角色是查看所有项目且数据量也比较大，所以把Ajax请求方式从POST改为了GET，结果就发现Ajax请求被缓存，只有第一次查询有效，其后全部是从缓存中取，查询资料后才发现是POST改为GET引起的 解决方法一12345678910//ajax get请求时比较简单 只需将cache设置为false就好 $.ajax(&#123; type: 'get',//get请求时 url: '........', cache: false,//不缓存 data: &#123; &#125;, success: function (result) &#123; &#125; &#125;); 解决方法二1234访问就在URL后面加上[总之就是使每次访问的URL字符串不一样的]URL?+new Date();设计WEB页面的时候 也应该遵守这个原则因为请求同一个地址会直接读取缓存，所以可以在参数中加一个随机数数 让每次参数不一样就好 IOS下Iframe滚动问题 移动端在IOS下的问题居多，后来测试组测出的bug多数属于在IOS下属性不兼容问题，其中就有IOS下Iframe里面页面无法滚动，解决方法如下 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="zh-cn"&gt;&lt;head&gt;&lt;meta charset="utf-8" /&gt;&lt;title&gt;IOS frame 滚动条 demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;style&gt;#wrapper&#123;height:500px;-webkit-overflow-scrolling:touch;overflow:auto;&#125;&lt;/style&gt;&lt;div class="container"&gt; 我是一堆很长。很长，很高，很高的内容。&lt;/div&gt;&lt;script src="../jquery.js"&gt;&lt;/script&gt;&lt;script&gt; var UA = navigator.userAgent; var forIOS = function()&#123; if(!UA.match(/iPad/) &amp;&amp; !UA.match(/iPhone/) &amp;&amp; !UA.match(/iPod/))&#123; return; &#125; if($('#wrapper').length)&#123;return;&#125; $('body').children().not('script').wrapAll('&lt;div id="wrapper"&gt;&lt;/div&gt;'); &#125;();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 总结这次是我第一次开发微信端，从前端的不熟悉到熟练，自己成长了许多。同时遇到了很多问题，尤其是在IOS下的兼容问题，比如还有像IOS下fixed属性不能用等问题。很多东西只有自己摸索才知道，这次也算是让自己在全栈工程师的道路上又进了一步。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MySQL优化]]></title>
      <url>%2F2017%2F04%2F17%2FMySQL%E4%BC%98%E5%8C%96%2F</url>
      <content type="text"><![CDATA[前言数据库在每个项目中都会用到，现在又分为两个门派，一种关系型数据库，常见的有MySQL、SQL Server、Oracle、DB2等。另一种是非关系型数据库，也就是NOSQL( Not Only SQL)，常见的NOSQL数据库有Redis 、MongoDB、Cassandra等。数据库的优化直接影响到网站的性能，在这里记录一下MySQL的优化。 关于MySQLMySQL 是一个跨平台的开源关系型数据库管理系统，目前 MySQL 被广泛地应用在 Internet 上的中小型网站中。由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，许多中小型网站为了降低网站总体拥有成本而选择了 MySQL 作为网站数据库。比如淘宝、京东等知名公司也都在使用。 MySQL的存储引擎有分为很多种。MyISAM、InnoDB等。每个引擎的特性都不一样，可以在不同的情况下选择不同的存储引擎。 MySQL的优化对于一个小项目来说，MySQL优化与否可能没有那么重要，带来的优化效果也没有那么明显。但是如果面对的是一个千万级的大表、千万级甚至上亿的数据量时，优化是必不可少的。那么要从如下几方面来做优化： 存储引擎一般情况可以选择MyISAM存储引擎，如果需要事务支持必须使用InnoDB存储引擎。 MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持以及外部键等高级数据库功能。 命名规则本着约定优先于配置（Convention Over Configuration）的原则，表的命名规则一样很重要。 MySQL数据库、表、字段等名称统一使用小写，单词间用_下划线分隔。 表名和字段名不宜过长（不超过64个字符）。 建议数据库统一设置编码为utf8，不仅仅是为了应付数据库间导入导出过程中、因编码格式不统一而导致的恼人的乱码问题，也是因为utf8是一种万国码（Unicode）。 语句+索引索引的合理建立和查询语句的优化可以迅速提升数据库性能。 设计阶段就需要预计QPS（Query Per Second）及数据规模，参考业务场景对数据的要求，合理设计表结构（参考mysql在线DDL问题），甚至违反设计范式做到适当冗余。生产环境分析慢日志，优化语句。索引的设计需要知道索引是怎么用的，比如innodb的加锁机制。 垃圾查询拖慢性能。不合理的schema设计也会导致数据存取慢。索引的作用不必多说，但如innodb下，错的索引带来的可能不只是查询变慢。 MySQL语句优化是我们最常见也是开发过程中最需要注意的。各种关键字的使用场合、多表之间的关联(据说阿里的要求是关联表不超多三个)、索引的合理使用、批量插入、批量更新、批量删除、临时表的使用等等。 缓存当数据库的压力太大时可以将一部分压力转嫁到缓存（我常用的是Redis），其流程如下： 复制及读写分离这个是大多数场景下都是必须的。因为复制可以实现备份、高可用、负载均衡。 其中读写分离可以在应用层做，效率高，也可以用三方工具，如360的atlas。 切分切分包括垂直切分和水平切分，实现方式上又包括分库、分表。 垂直切分保证业务的独立性，防止不同业务争抢资源，毕竟业务是有优先级的。 水平切分主要用于突破单机瓶颈。除了主主外，只有切分能真正做到将负载分配下去。 切分后也可对不同片数据进行不同优化。如按时间切分，超过一定时间数据不允许修改，就可以引入压缩了，数据传输及读取减少很多。 根据业务垂直切分。业务内部分库、分表。一般都需要修改应用。除分表外，其余实现不是很复杂。有第三方组件可用，但通用高效又灵活的方式，还是自己写client。 垂直切分一般都要做，只不过业务粒度大小而已。 分库有是经常用的，就算当前压力小，也尽量分出几个逻辑库出来。等规模上去了，很方便就迁移扩展。 水平拆分有一定难度，但如果将来一定会到这个规模，又可能用到，建议越早做越好。因为对应用的改动较大，而且迁移成本高。 总结MySQL总结可以说是： 优化SQL，优化结构，优化存储。 对于MySQL的优化我还需要进一步提高，从表的设计建立到后期的维护考虑的问题有很多，每一步都需要注意。没有DBA，只有自己来实现。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux基本命令]]></title>
      <url>%2F2017%2F04%2F07%2FLinux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[前言之前的公司有用过Linux，自己也学习了一段时间，但是很久没有用了，最近又在腾讯云租了个空间把系统装成Centos系统了，所以又把Linux系统重新捡起来，重温下Linux的基本知识。 Linux简介简介Linux，免费开源，多用户多任务系统。基于Linux有多个版本的衍生。RedHat、Ubuntu、Debian 安装VMware或VirtualBox虚拟机。Linux的定义和历史右转百度百科。具体安装步骤，找百度。 常用版本我常用的Linux版本有两个Centos和Ubuntu，全都是开源免费的,其中Ubuntu属于桌面版。 123Centos是免费的企业版Linux操作系统。是RedHat企业版的优化操作系统。具体可以参照百科：http://baike.baidu.com/view/26404.htm。里面有详解。另附其官网:http://www.centos.org/。另外，它适合作为服务器用。 1Ubuntu之前有在环境中开发过项目，虽然时间不久，但还是有所体会。免费、无毒、免折腾、比较接近底层。 基本命令 Linux 操作系统位数识别: uname -a（uname -p） Linux 32位操作系统：Linux x86 i586 i386 i686 i… Linux 64位操作系统：Linux x64x86_64 X64 … man 命令不会用了，找男人 如：man ls ifconfig 显示系统信息 ls 或ll 查看目录文件 pwd 查看目前路径 cat 文件名 从第一个字节开始正向查看文件的内容 head -2 file1 查看一个文件的前两行 tail -2 file1 查看一个文件的最后两行 mv 老名 新名 重命名/剪切 cp 老文件路径+文件名 新文件路径（+文件名） 复制 cd 进入个人的主目录 cd 路径名 进入新路径 cd .. 后退一步 date 显示系统日期 shutdown -h now 关闭系统(1) shutdown -r now 重启(1) reboot 重启(2) halt 关机(推荐) logout 注销 mkdir dir1 创建一个叫做 ‘dir1’ 的目录’ rm -f file1 删除一个叫做 ‘file1’ 的文件’ rmdir dir1 删除一个叫做 ‘dir1’ 的目录’ rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内 find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录 tar -zxvf archive.tar 解压一个包 rpm -ivh package.rpm 安装一个rpm包 高级一点的命令，也是比较难懂、需要实践和琢磨的命令： chmod +权限(ugo) (u、g、o表示user、group、other) 三种基本权限 R 读 数值表示为4 W 写 数值表示为2 X 可执行 数值表示为1 ​ 例如：chmod 777 表示user、group、other都具有RWX权限。 grep [options] grep命令是一种强大的文本搜索工具 grep ‘test’ d*显示所有以d开头的文件中包含 test的行。 ps [options] 对进程进行监测和控制 ps -aux|grep 8080 查看8080端口占用情况 yum yum [options][command] [package ...] 工具 yum list 列出当前系统中安装的所有包 wget wget [OPTION]… [URL]… wget是一个从网络上自动下载文件的自由工具 wget http://example.com/file.iso 从网上下载单个文件 …………… 总结Linux博大精深，有很多的命令自己使用的比较少也没有用到，用到的时候再去查资料。 更多的命令可以查看http://www.cnblogs.com/skillup/articles/1877812.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JAVA实现简单网络爬虫]]></title>
      <url>%2F2017%2F04%2F01%2FJAVA%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB%2F</url>
      <content type="text"><![CDATA[爬虫基本理解 通俗一点，爬虫是用来快速、批量获取我们在网络需要的东西，过滤掉不需要的东西，比如我可以爬一个网站的所有图片省的一张一张去保存，也可以爬其他数据来做研究、统计、数据分析，即是： (1) 对抓取目标的描述或定义； (2) 对网页或数据的分析与过滤； (3) 对URL的搜索策略。 很多语言都可以做爬虫，在这里记录JAVA做一个简单的爬虫，等以后学会其他语言了再用其他语言做爬虫，哈哈… 实现爬虫需要知识点 简单HTML、CSS、JS等前端知识 正则表达式（很重要，用于过滤不需要的信息） JAVA语言知识（可换成其他语言） 参数 首先你要给它一个种子链接URL 在种子链接的页面查找其他的URL，重复1步骤 有链接有页面，然后你可以在页面中查找需要的内容 简单爬虫代码在这里做个示例：把网站https://www.baidu.com/home/news/data/newspage?nid=7953839918275534&amp;n_type=0&amp;p_from=1 图片全部down下来并保存到本地磁盘的操作。 JAVA基本方式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class Reptile &#123; public static String doGet(String urlStr) throws Exception &#123; URL url; String html = ""; try &#123; url = new URL(urlStr); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setRequestProperty("Accept", "text/html"); connection.setRequestProperty("Accept-Charset", "utf-8"); connection.setRequestProperty("Accept-Language", "en-US,en"); connection.setRequestProperty("User-Agent", "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.22 (KHTML, like Gecko) Chrome/25.0.1364.160 Safari/537.22"); connection.setRequestMethod("GET"); connection.setConnectTimeout(5000); connection.setDoInput(true); connection.setDoOutput(true); if (connection.getResponseCode() == 200) &#123; System.out.println("已连接，正在解析。。。。。。"); InputStream in = connection.getInputStream(); html = StreamTool.inToStringByByte(in); &#125; else &#123; System.out.println(connection.getResponseCode()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); throw new Exception("get请求失败"); &#125; return html; &#125; public static void main(String[] args) throws Exception &#123; Reptile reptile = new Reptile() String htmlStr = Reptile.doGet("https://www.baidu.com/home/news/data/ newspagenid=7953839918275534&amp;n_type=0&amp;p_from=1"); File f = new File("E://imgs"); if (!f.exists()) &#123; f.mkdirs(); &#125; Pattern pattern = Pattern.compile("&lt;img.*src=(.*?)[^&gt;]*?&gt;"); //匹配Imag标签 Matcher matcher = pattern.matcher(htmlStr); // 定义一个matcher用来做匹配 System.out.println("正在下载"); while (matcher.find()) &#123; String imgs = matcher.group(); Matcher srcMatcher = Pattern.compile("https:\"?(.*?)(\"|&gt;|\\s+)").matcher(imgs); while (srcMatcher.find()) &#123; String src = srcMatcher.group().substring(0,srcMatcher.group().length() - 1); System.out.println(src); // 获取后缀名 String imageName = src.substring(src.lastIndexOf("/") + 1,src.length()); reptile.downLoad(src, imageName); //下载图片到本地 &#125; &#125; &#125; //下载图片到本地 public void downLoad(String src, String imageName) throws Exception &#123; URL url = new URL(src); URLConnection uri = url.openConnection(); InputStream is = uri.getInputStream(); // 获取数据流 // 写入数据流 OutputStream os = new FileOutputStream(new File("E://imgs", imageName)); byte[] buf = new byte[1024]; int len = 0; while ((len = is.read(buf)) != -1) &#123; os.write(buf, 0, len); &#125; os.close(); is.close(); &#125;&#125; JAVA基本方法主要是利用JAVA中的正则表达式匹配我们我需要的元素，然后再进行其他操作。简单、粗暴。 Jsoup方式 Jsoup 是一个 Java 的开源HTML解析器，可直接解析某个URL地址、HTML文本内容。同时提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。可以直接使用DOM或者JQuery方法和表达式取出数据。 需要下载JAR包，下载地址：点我 Jsoup API：详见：http://www.open-open.com/jsoup/ 工具类StreamTool ：将byte对象转化为String对象 1234567891011121314public class StreamTool &#123;// 将byte对象转化为String对象 public static String inToStringByByte(InputStream in) throws Exception &#123; ByteArrayOutputStream outStr = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len = 0; StringBuilder content = new StringBuilder(); while ((len = in.read(buffer)) != -1) &#123; content.append(new String(buffer, 0, len, "UTF-8")); &#125; outStr.close(); return content.toString(); &#125;&#125; 基本实现类Reptile 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Reptile &#123; public static String doGet(String urlStr) throws Exception &#123; URL url; String html = ""; try &#123; url = new URL(urlStr); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); //伪装爬虫，不然会报403错误 connection.setRequestProperty("Accept", "text/html"); connection.setRequestProperty("Accept-Charset", "utf-8"); connection.setRequestProperty("Accept-Language", "en-US,en"); connection.setRequestProperty("User-Agent","Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.22 (KHTML, like Gecko) Chrome/25.0.1364.160 Safari/537.22"); connection.setRequestMethod("GET"); // 定义请求方式 connection.setConnectTimeout(5000); connection.setDoInput(true); //设置是否向httpUrlConnection输出， 默认情况下是false; connection.setDoOutput(true); // 设置是否从httpUrlConnection读入，默认情况下是true; if (connection.getResponseCode() == 200) &#123; //连接成功 System.out.println("已连接，正在解析。。。。。。"); InputStream in = connection.getInputStream(); html = StreamTool.inToStringByByte(in); &#125; else &#123; System.out.println(connection.getResponseCode()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); throw new Exception("get请求失败"); &#125; return html; &#125; public static void main(String[] args) throws Exception &#123; URL url ; InputStream is = null; OutputStream os = null; String urlStr = "https://www.baidu.com/home/news/data/newspage?nid=7953839918275534&amp;n_type=0&amp;p_from=1"; String htmlStr = Reptile.doGet(urlStr); Document doc = Jsoup.parse(htmlStr); // 将获取的网页 HTML 源代码转化为 Document对象 File f = new File("E://imgs"); //把文件存在E://imgs if (!f.exists()) &#123; f.mkdirs(); &#125; Elements pngs = doc.select("img[src]"); //获取所有图片// Elements pngs = doc.select("img[src$=.png]");只爬取png图片 int i = 1; //计数 for (Element e : pngs) &#123; String src = e.attr("src"); // 获取img中的src路径 String imageName = src.substring(src.lastIndexOf("/") + 1, src.length()); // 获取后缀名 System.out.println("正在下载第" + i + "张图片："+ imageName); URL url = new URL(src); // 连接url URLConnection uri = url.openConnection(); is = uri.getInputStream(); // 获取数据流 os = new FileOutputStream(new File("E://imgs",imageName));// 写入数据流 byte[] buf = new byte[1024]; int len = 0; while ((len = is.read(buf)) != -1) &#123; os.write(buf, 0, len); &#125; i++; &#125; os.close(); is.close(); System.out.println("共有" + (i-1) + "张图片。"); &#125;&#125; 总结在这里只做个一个简单的爬虫示例，通过两种方式的比较后，发现Jsoup更佳。 JAVA基本的方式能用正则表达式来匹配所需要的元素，灵活性不高。 Jsoup这个强大的工具提供了DOM和JQuery方法，可以直接操作节点，同时也支持正则表达式，更加的灵活、省力，同时选择性、可玩性和扩展性更高。Jsoup更多的方法可以查看Jsoup的API。 现在已经有很多开源的爬虫的框架供我们选择，比如webmagic、Heritrix等，可以适当选择。 附还有一种更为简单强大的方式，在Linux环境下，利用wget命令只需要一行命令就可以实现以上功能。 1wget -m -H -nd -l 1 -t 1 -A .jpg,.png,.jpeg,.JPEG -e robots=off -P /opt/download --no-check-certificate https://www.baidu.com/home/news/data/newspage?nid=7953839918275534&amp;n_type=0&amp;p_from=1 在下篇博客写一下Linux的基本命令。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JAVA定时调度 Timer和Executors]]></title>
      <url>%2F2017%2F03%2F27%2FJAVA%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6-Timer%E5%92%8CExecutors%2F</url>
      <content type="text"><![CDATA[近期在公司做了一个关于定时执行任务的功能（没有使用框架定时），查了一下资料，有Thread、Timer和Executors三种方法，之前使用的是Timer，但是详细查了资料觉得Executors更优，所以在这里比较一下它们的区别。 Thread类这是最基本的，创建一个Thread，然后让它在while循环里一直运行着，通过sleep方法来达到定时任务的效果。这样可以快速简单的实现，代码如下： 12345678910111213141516171819202122public class Task1 &#123; public static void main(String[] args) &#123; // run in a second final long timeInterval = 1000; Runnable runnable = new Runnable() &#123; public void run() &#123; while (true) &#123; // ------- code for task to run System.out.println("Hello !!"); // ------- ends here try &#123; Thread.sleep(timeInterval); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; Thread thread = new Thread(runnable); thread.start(); &#125; &#125; Thread的做定时任务的几率不大，因为不可控制启动停止时间、不能指定想要的delay时间。 Timer类 于第一种方式相比，优势 : (1) 当启动和去取消任务时可以控制 ; (2) 第一次执行任务时可以指定你想要的delay时间。 在实现时，Timer类可以调度任务，TimerTask则是通过在run()方法里实现具体任务。 Timer实例可以调度多任务，它是线程安全的。 当Timer的构造器被调用时，它创建了一个线程，这个线程可以用来调度任务。 12345678910111213141516public class Task2 &#123; public static void main(String[] args) &#123; TimerTask task = new TimerTask() &#123; @Override public void run() &#123; // task to run goes here System.out.println("Hello !!!"); &#125; &#125;; Timer timer = new Timer(); long delay = 0; long intevalPeriod = 1 * 1000; // schedules the task to be run in an interval timer.scheduleAtFixedRate(task, delay, intevalPeriod); &#125; // end of main &#125; 缺点：如果TimerTask抛出未检查的异常，Timer将会产生无法预料的行为。Timer线程并不捕获异常，所以 TimerTask抛出的未检查的异常会终止timer线程。这种情况下，Timer也不会再重新恢复线程的执行了;它错误的认为整个Timer都被取消了。此时，已经被安排但尚未执行的TimerTask永远不会再执行了，新的任务也不能被调度了。 Executors ScheduledExecutorService是从Java SE5的java.util.concurrent里，做为并发工具类被引进的，这是最理想的定时任务实现方式。 相比于上两个方法，它有以下好处 : (1) 相比于Timer的单线程，它是通过线程池的方式来执行任务的 ; (2) 可以很灵活的去设定第一次执行任务delay时间 ; (3) 提供了良好的约定，以便设定执行的时间间隔 。 下面是实现代码，我们通过ScheduledExecutorService展示这个例子，通过代码里参数的控制，首次执行加了delay时间。 1234567891011121314public class Task3 &#123; public static void main(String[] args) &#123; Runnable runnable = new Runnable() &#123; public void run() &#123; // task to run goes here System.out.println("Hello !!"); &#125; &#125;; ScheduledExecutorService service = Executors .newSingleThreadScheduledExecutor(); // 第二个参数为首次执行的延时时间，第三个参数为定时执行的间隔时间 service.scheduleAtFixedRate(runnable, 10, 1, TimeUnit.SECONDS); &#125; &#125; 线程池能按时间计划来执行任务，允许用户设定计划执行任务的时间。 当任务较多时，线程池可能会自动创建更多的工作线程来执行任务 。 支持多个任务并发执行。 总结Timer是单线程的。所以task都是串行执行。假如其中一个task执行需要很长的时间，那其他的task只能干巴巴的等着。 ScheduledThreadPoolExecutor是一个可以重复执行任务的线程池，并且可以指定任务的间隔和延迟时间。它作为比Timer/TimerTask更加通用的替代品。因为它允许多个服务线程，接受不同的时间单位，且不需要继承TimeTask（仅仅需要实现Runnable接口）。配置ScheduledThreadPoolExecutor为单线程，则与使用Timer等效。 上述，基本说明了在以后的开发中尽可能使用ScheduledExecutorService(JDK1.5以后)替代Timer。 下面是自己做的功能，通过短信API定时查询教师回复信息并更新数据库。 123456789101112131415161718192021222324252627282930/** * 定时查询教师回复状态 * @param a */public void getStatusSchedule(final Date replyEnd)&#123; final SendMessage sendMsg = new SendMessage(); final ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor(); service.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; try &#123; Date nowDate = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()));//当前时间 //若截至时间在当前时间之前执行定时任务 否则不执行 if (!nowDate.before(replyEnd)) &#123; service.shutdown(); //停止任务 return; &#125;else &#123; Map&lt;String,Object&gt; map = sendMsg.getReplyMsg(); //获取回复信息 if(!map.isEmpty())&#123; //当map不为空时执行 updateMsgStatus(map); //更新数据库 &#125; &#125; &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, 1, 1, TimeUnit.MINUTES); //执行后第一次查询在1分钟之后，每隔1分钟查询一次。 &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈共享单车]]></title>
      <url>%2F2017%2F03%2F24%2F%E6%B5%85%E8%B0%88%E5%85%B1%E4%BA%AB%E5%8D%95%E8%BD%A6%2F</url>
      <content type="text"><![CDATA[​ 要说目前最火爆的互联网现象，当属共享单车。这里所谓的共享，本质上指的是需求共享。就骑车的需求，从一个地方骑到另一个地方，就是用户触点（产品投放）、产品操作（骑行过程）、付费模式（支付）的流程，从个体上来讲，这个流程是单向的。但在“共享”的模式下，扫码骑走，停车即走，把不同的人，在不同的时间和地点，相同的骑行需求，通过产品操作节点，形成需求闭环，停车点同时又是骑行出发点，这就是需求共享。 共享单车是指企业与政府合作，在地铁、学校、公交站点、居民区、商业区、公共服务区等提供自行车单车共享服务，是共享经济的一种新形态。 ​ 2016年底以来，国内共享单车突然就火爆了起来，而在街头，仿佛一夜之间，共享单车已经到了“泛滥”的地步，各大城市路边排满各种颜色的共享单车。 场景分析​ 我们站在用户角度，无非就是找车，然后骑车，交钱。 在“寻车-用车-骑车-还车”的场景闭环中，需要考虑的问题有很多，列举以下若干种： 什么样的寻车方式更符合大众的日常行为？ 用户与单车之间如何建立一一对应的联系？ 使用何种开锁构件实现远程开锁和上锁？ 计费方式及费用节点、价格、操作流程分别采取什么方案？ 如何对车辆进行远程管理？ 如何防止逃费、盗窃、破坏等衍生问题？ 场景分析的过程，就是解决以上若干问题的过程，针对这些问题，分别提出不同的业务流程和技术方案。 业务逻辑分析以摩拜单车为例，用户-管理平台-单车 之间的关系如下图: 技术实现方案​ 现在共享单车最火的要数摩拜单车和OFO小黄车了，摩拜采用智能锁而ofo采用的是机械锁。 1 机械锁​ 原理：机械锁的原理很简单，只需要打开软件，输入对应的车牌号就可以了，其实就是后台查询数据库，判断单车是否处于正常状态，返回给用户开锁密码，用户拿着开锁密码开锁。 2 智能锁​ 原理：对于单车的远程开锁机制，采用远程通信控制机械构件的电磁运动来实现。远程通信可采用传统的SIM卡通信的方式。 一、手机扫描自行车，获得自行车唯一的ID标志，手机接着会像服务器提交一个请求（提交信息里包含：用户信息，请求动作，车辆ID）；二、服务器收到用户开锁请求，此时会根据请求信息，接着向指定ID的自行车发出开锁指令;三、自行车收到服务器请求，会执行相应的开锁动作。 智能锁是耗费电能的，所以摩拜单车车篮中装有太阳能电池板，减少人力物力维护的成本、简单、高效。 ​ 这是一个典型的大容量互联网O2O场景，连结用户、车辆，管理平台进行实时处理效率要求非常高，需制定可靠、高效的网络方案。根据业务流程，我们梳理出网络节点的职能，并从成本考虑使用最优方案： ​ 明确流程，界面，那么接下来的任务就是通过用户语言去实现产品流程了，即界面设计与开发实现，这里我们就不阐述了。 一点感想​ 从2016年到现在已有近半年时间，共享单车的竞争也愈演愈烈，近几天，共享单车从免费到红包“撒钱” 导致竞争升级，共享单车方便了我们的出行，但是带来的问题也很多，政府也在不断的规范使用。现在都在处于资本投入和烧钱大战中，希望共享单车一直存货下去，同时希望大家能合理、合法使用。 之前有听说过摩拜的扫一扫可以远程使用，假如我需要车又没有注册，我可以拍照给有车的朋友，让他们帮我远程扫就可以开启，亲测：不行！还是自己乖乖注册一个吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown语法指南]]></title>
      <url>%2F2017%2F03%2F21%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[花了一段时间把自己的个人博客搭建好了，但是博客必须是要用Markdown书写，所以查了一下Markdown编辑器的语法，在这里做个记录。 Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown。完全采用Markdown编辑器的博客平台有Ghost和Typecho。 基本技巧1 代码如果你只想高亮语句中的某个函数名或关键字，可以使用 `function_name()` 实现 通常编辑器根据代码片段适配合适的高亮方法，但你也可以用 ``` 包裹一段代码，并指定一种语言 12345​```javascript$(document).ready(function () &#123; alert('hello world');&#125;);​``` 支持的语言：actionscript, apache, bash, clojure, cmake, coffeescript, cpp, cs, css, d, delphi, django, erlang, go, haskell, html, http, ini, java, javascript, json, lisp, lua, markdown, matlab, nginx, objectivec, perl, php, python, r, ruby, scala, smalltalk, sql, tex, vbscript, xml 也可以使用 4 空格缩进，再贴上代码，实现相同的的效果 123 def g(x): yield from range(x, 0, -1) yield from range(x) 2 标题文章内容较多时，可以用标题分段： 12345678标题1======标题2-----## 大标题 ##### 小标题 ### 3 粗斜体123*斜体文本* _斜体文本_**粗体文本** __粗体文本__***粗斜体文本*** ___粗斜体文本___ 4 链接4.1 常用链接方法 12文字链接 ![链接名称](http://链接网址)网址链接 &lt;http://链接网址&gt; 4.2 高级链接技巧 123456这个链接用 1 作为网址变量 [Google][1].这个链接用 yahoo 作为网址变量 [Yahoo!][yahoo].然后在文档的结尾为变量赋值（网址） [1]: http://www.google.com/ [yahoo]: http://www.yahoo.com/ 5 列表5.1 普通无序列表 123- 列表文本前使用 [减号+空格]+ 列表文本前使用 [加号+空格]* 列表文本前使用 [星号+空格] 5.2 普通有序列表 1231. 列表前使用 [数字+空格]2. 我们会自动帮你添加数字7. 不用担心数字不对，显示的时候我们会自动把这行的 7 纠正为 3 5.3 列表嵌套 12345678910111213141516171. 列出所有元素： - 无序列表元素 A 1. 元素 A 的有序子列表 - 前面加四个空格2. 列表里的多段换行： 前面必须加四个空格， 这样换行，整体的格式不会乱3. 列表里引用： &gt; 前面空一行 &gt; 仍然需要在 &gt; 前面加四个空格4. 列表里代码段：前面四个空格，之后按代码语法 ``` 书写​``` 或者直接空八个，引入代码块 6 引用6.1 普通引用 12&gt; 引用文本前使用 [大于号+空格]&gt; 折行可以不加，新起一行都要加上哦 6.2 引用里嵌套引用 123&gt; 最外层引用&gt; &gt; 多一个 &gt; 嵌套一层引用&gt; &gt; &gt; 可以嵌套很多层 6.3 引用里嵌套列表 123&gt; - 这是引用里嵌套的一个列表&gt; - 还可以有子列表&gt; * 子列表需要从 - 之后延后四个空格开始 6.4 引用里嵌套代码块 12345&gt; 同样的，在前面加四个空格形成代码块&gt; &gt; &gt; 或者使用 ``` 形成代码块&gt; `` 7 图片7.1 跟链接的方法区别在于前面加了个感叹号 !，这样是不是觉得好记多了呢？ 1![图片名称](http://图片网址) 7.2 当然，你也可以像网址那样对图片网址使用变量 1234这个链接用 1 作为网址变量 [Google][1].然后在文档的结尾位变量赋值（网址） [1]: http://www.google.com/logo.png 也可以使用 HTML 的图片语法来自定义图片的宽高大小 1&lt;img src="htt://example.com/sample.png" width="400" height="100"&gt; 8 换行如果另起一行，只需在当前行结尾加 2 个空格 12在当前行的结尾加 2 个空格 这行就会新起一行 如果是要起一个新段落，只需要空出一行即可。 9 分隔符如果你有写分割线的习惯，可以新起一行输入三个减号-。当前后都有段落时，请空出一行： 12345前面的段落---后面的段落 高级技巧1 行内 HTML 元素目前只支持部分段内 HTML 元素效果，包括 ，如 键位显示 1使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑 代码块 1使用 &lt;pre&gt;&lt;/pre&gt; 元素同样可以形成代码块 粗斜体 1&lt;b&gt; Markdown 在此处同样适用，如 *加粗* &lt;/b&gt; 2 符号转义如果你的描述中需要用到 markdown 的符号，比如 _ # * 等，但又不想它被转义，这时候可以在这些符号前加反斜杠，如 \_ \#``\* 进行避免。 12\_不想这里的文本变斜体\_\*\*不想这里的文本被加粗\*\* 3 扩展支持 jsfiddle、gist、runjs、优酷视频，直接填写 url，在其之后会自动添加预览点击会展开相关内容。 1234http://&#123;url_of_the_fiddle&#125;/embedded/[&#123;tabs&#125;/[&#123;style&#125;]]/https://gist.github.com/&#123;gist_id&#125;http://runjs.cn/detail/&#123;id&#125;http://v.youku.com/v_show/id_&#123;video_id&#125;.html 4 公式当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如： 12345$$ x = &#123;-b \pm \sqrt&#123;b^2-4ac&#125; \over 2a&#125;. $$$$x \href&#123;why-equal.html&#125;&#123;=&#125; y^2 + 1$$ 同时也支持 HTML 属性，如： 12345$$ (x+1)^2 = \class&#123;hidden&#125;&#123;(x+1)(x+1)&#125; $$$$(x+1)^2 = \cssId&#123;step1&#125;&#123;\style&#123;visibility:hidden&#125;&#123;(x+1)(x+1)&#125;&#125;$$ 总结markdown语法写多了自然就会了，网上有很多markdown语法编辑器，比如有道云、马克飞象、Typora等。我目前使用的是Typora编辑器，使用起来比其他的更简单、舒适，方便。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[博客建成第一天]]></title>
      <url>%2F2017%2F03%2F07%2F%E5%8D%9A%E5%AE%A2%E5%BB%BA%E6%88%90%E7%AC%AC%E4%B8%80%E5%A4%A9%2F</url>
      <content type="text"><![CDATA[经过几天的努力，自己的博客终于搭建起来了，打心里很开心。 这不是贴吧，不是豆瓣，不是CSDN，这是我自己在互联网上的一小点领地。 从开始博客基本样式，到域名，自己一步一步摸索搭建起来的，我相信自己可以做的更好，加油!]]></content>
    </entry>

    
  
  
</search>
