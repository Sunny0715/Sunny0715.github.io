<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[MySQL优化]]></title>
      <url>%2F2017%2F04%2F17%2FMySQL%E4%BC%98%E5%8C%96%2F</url>
      <content type="text"><![CDATA[前言数据库在每个项目中都会用到，现在又分为两个门派，一种关系型数据库，常见的有MySQL、SQL Server、Oracle、DB2等。另一种是非关系型数据库，也就是NOSQL( Not Only SQL)，常见的NOSQL数据库有Redis 、MongoDB、Cassandra等。数据库的优化直接影响到网站的性能，在这里记录一下MySQL的优化。 关于MySQLMySQL 是一个跨平台的开源关系型数据库管理系统，目前 MySQL 被广泛地应用在 Internet 上的中小型网站中。由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，许多中小型网站为了降低网站总体拥有成本而选择了 MySQL 作为网站数据库。比如淘宝、京东等知名公司也在使用。 MySQL的存储引擎有分为很多种。MyISAM、InnoDB等。每个引擎的特性都不一样，可以在不同的情况下选择不同的存储引擎。 MySQL的优化对于一个小项目来说，MySQL优化与否可能没有那么重要，带来的优化效果也没有那么明显。但是如果面对的是一个千万级的大表、千万级甚至上亿的数据量时，优化是必不可少的。那么要从如下几方面来做优化： 存储引擎一般情况可以选择MyISAM存储引擎，如果需要事务支持必须使用InnoDB存储引擎。 MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持以及外部键等高级数据库功能。 命名规则本着约定优先于配置（Convention Over Configuration）的原则，表的命名规则一样很重要。 MySQL数据库、表、字段等名称统一使用小写，单词间用_下划线分隔。 表名和字段名不宜过长（不超过64个字符）。 建议数据库统一设置编码为utf8，不仅仅是为了应付数据库间导入导出过程中、因编码格式不统一而导致的恼人的乱码问题，也是因为utf8是一种万国码（Unicode） 语句+索引索引的合理建立和查询语句的优化可以迅速提升数据库性能。 设计阶段就需要预计QPS（Query Per Second）及数据规模，参考业务场景对数据的要求，合理设计表结构（参考mysql在线DDL问题），甚至违反设计范式做到适当冗余。生产环境分析慢日志，优化语句。索引的设计需要知道索引是怎么用的，比如innodb的加锁机制。 垃圾查询拖慢性能。不合理的schema设计也会导致数据存取慢。索引的作用不必多说，但如innodb下，错的索引带来的可能不只是查询变慢。 MySQL语句优化是我们最常见也是开发过程中最需要注意的。各种关键字的使用场合、多表之间的关联(据说阿里的要求是关联表不超多三个)、索引的合理使用、批量插入、批量更新、批量删除、临时表的使用等等。 缓存当数据库的压力太大时可以将一部分压力转嫁到缓存（我常用的是Redis），其流程如下： 复制及读写分离这个是大多数场景下都是必须的。因为复制可以实现备份、高可用、负载均衡。 其中读写分离可以在应用层做，效率高，也可以用三方工具，如360的atlas。 切分切分包括垂直切分和水平切分，实现方式上又包括分库、分表。 垂直切分保证业务的独立性，防止不同业务争抢资源，毕竟业务是有优先级的。 水平切分主要用于突破单机瓶颈。除了主主外，只有切分能真正做到将负载分配下去。 切分后也可对不同片数据进行不同优化。如按时间切分，超过一定时间数据不允许修改，就可以引入压缩了，数据传输及读取减少很多。 根据业务垂直切分。业务内部分库、分表。一般都需要修改应用。除分表外，其余实现不是很复杂。有第三方组件可用，但通用高效又灵活的方式，还是自己写client。 垂直切分一般都要做，只不过业务粒度大小而已。 分库有是经常用的，就算当前压力小，也尽量分出几个逻辑库出来。等规模上去了，很方便就迁移扩展。 水平拆分有一定难度，但如果将来一定会到这个规模，又可能用到，建议越早做越好。因为对应用的改动较大，而且迁移成本高。 总结MySQL总结可以说是： 优化SQL，优化结构，优化存储。 对于MySQL的优化我还需要进一步提高，从表的设计建立到后期的维护考虑的问题有很多，每一步都需要注意。没有DBA，只有自己来实现。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux基本命令]]></title>
      <url>%2F2017%2F04%2F07%2FLinux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[前言之前的公司有用过Linux，自己也学习了一段时间，但是很久没有用了，最近又在腾讯云租了个空间把系统装成Centos系统了，所以又把Linux系统重新捡起来，重温下Linux的基本知识。 Linux简介简介Linux，免费开源，多用户多任务系统。基于Linux有多个版本的衍生。RedHat、Ubuntu、Debian 安装VMware或VirtualBox虚拟机。Linux的定义和历史右转百度百科。具体安装步骤，找百度。 常用版本我常用的Linux版本有两个Centos和Ubuntu，全都是开源免费的,其中Ubuntu属于桌面版。 123Centos是免费的企业版Linux操作系统。是RedHat企业版的优化操作系统。具体可以参照百科：http://baike.baidu.com/view/26404.htm。里面有详解。另附其官网:http://www.centos.org/。另外，它适合作为服务器用。 1Ubuntu之前有在环境中开发过项目，虽然时间不久，但还是有所体会。免费、无毒、免折腾、比较接近底层。 基本命令 Linux 操作系统位数识别: uname -a（uname -p） Linux 32位操作系统：Linux x86 i586 i386 i686 i… Linux 64位操作系统：Linux x64x86_64 X64 … man 命令不会用了，找男人 如：man ls ifconfig 显示系统信息 ls 或ll 查看目录文件 pwd 查看目前路径 cat 文件名 从第一个字节开始正向查看文件的内容 head -2 file1 查看一个文件的前两行 tail -2 file1 查看一个文件的最后两行 mv 老名 新名 重命名/剪切 cp 老文件路径+文件名 新文件路径（+文件名） 复制 cd 进入个人的主目录 cd 路径名 进入新路径 cd .. 后退一步 date 显示系统日期 shutdown -h now 关闭系统(1) shutdown -r now 重启(1) reboot 重启(2) halt 关机(推荐) logout 注销 mkdir dir1 创建一个叫做 ‘dir1’ 的目录’ rm -f file1 删除一个叫做 ‘file1’ 的文件’ rmdir dir1 删除一个叫做 ‘dir1’ 的目录’ rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内 find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录 tar -zxvf archive.tar 解压一个包 rpm -ivh package.rpm 安装一个rpm包 高级一点的命令，也是比较难懂、需要实践和琢磨的命令： chmod +权限(ugo) (u、g、o表示user、group、other) 三种基本权限 R 读 数值表示为4 W 写 数值表示为2 X 可执行 数值表示为1 ​ 例如：chmod 777 表示user、group、other都具有RWX权限。 grep [options] grep命令是一种强大的文本搜索工具 grep ‘test’ d*显示所有以d开头的文件中包含 test的行。 ps [options] 对进程进行监测和控制 ps -aux|grep 8080 查看8080端口占用情况 yum yum [options][command] [package ...] 工具 yum list 列出当前系统中安装的所有包 wget wget [OPTION]… [URL]… wget是一个从网络上自动下载文件的自由工具 wget http://example.com/file.iso 从网上下载单个文件 …………… 总结Linux博大精深，有很多的命令自己使用的比较少也没有用到，用到的时候再去查资料。 更多的命令可以查看http://www.cnblogs.com/skillup/articles/1877812.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JAVA实现简单网络爬虫]]></title>
      <url>%2F2017%2F04%2F01%2FJAVA%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB%2F</url>
      <content type="text"><![CDATA[爬虫基本理解 通俗一点，爬虫是用来快速、批量获取我们在网络需要的东西，过滤掉不需要的东西，比如我可以爬一个网站的所有图片省的一张一张去保存，也可以爬其他数据来做研究、统计、数据分析，即是： (1) 对抓取目标的描述或定义； (2) 对网页或数据的分析与过滤； (3) 对URL的搜索策略。 很多语言都可以做爬虫，在这里记录JAVA做一个简单的爬虫，等以后学会其他语言了再用其他语言做爬虫，哈哈… 实现爬虫需要知识点 简单HTML、CSS、JS等前端知识 正则表达式（很重要，用于过滤不需要的信息） JAVA语言知识（可换成其他语言） 参数 首先你要给它一个种子链接URL 在种子链接的页面查找其他的URL，重复1步骤 有链接有页面，然后你可以在页面中查找需要的内容 简单爬虫代码在这里做个示例：把网站https://www.baidu.com/home/news/data/newspage?nid=7953839918275534&amp;n_type=0&amp;p_from=1 图片全部down下来并保存到本地磁盘的操作。 JAVA基本方式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class Reptile &#123; public static String doGet(String urlStr) throws Exception &#123; URL url; String html = ""; try &#123; url = new URL(urlStr); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setRequestProperty("Accept", "text/html"); connection.setRequestProperty("Accept-Charset", "utf-8"); connection.setRequestProperty("Accept-Language", "en-US,en"); connection.setRequestProperty("User-Agent", "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.22 (KHTML, like Gecko) Chrome/25.0.1364.160 Safari/537.22"); connection.setRequestMethod("GET"); connection.setConnectTimeout(5000); connection.setDoInput(true); connection.setDoOutput(true); if (connection.getResponseCode() == 200) &#123; System.out.println("已连接，正在解析。。。。。。"); InputStream in = connection.getInputStream(); html = StreamTool.inToStringByByte(in); &#125; else &#123; System.out.println(connection.getResponseCode()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); throw new Exception("get请求失败"); &#125; return html; &#125; public static void main(String[] args) throws Exception &#123; Reptile reptile = new Reptile() String htmlStr = Reptile.doGet("https://www.baidu.com/home/news/data/ newspagenid=7953839918275534&amp;n_type=0&amp;p_from=1"); File f = new File("E://imgs"); if (!f.exists()) &#123; f.mkdirs(); &#125; Pattern pattern = Pattern.compile("&lt;img.*src=(.*?)[^&gt;]*?&gt;"); //匹配Imag标签 Matcher matcher = pattern.matcher(htmlStr); // 定义一个matcher用来做匹配 System.out.println("正在下载"); while (matcher.find()) &#123; String imgs = matcher.group(); Matcher srcMatcher = Pattern.compile("https:\"?(.*?)(\"|&gt;|\\s+)").matcher(imgs); while (srcMatcher.find()) &#123; String src = srcMatcher.group().substring(0,srcMatcher.group().length() - 1); System.out.println(src); // 获取后缀名 String imageName = src.substring(src.lastIndexOf("/") + 1,src.length()); reptile.downLoad(src, imageName); //下载图片到本地 &#125; &#125; &#125; //下载图片到本地 public void downLoad(String src, String imageName) throws Exception &#123; URL url = new URL(src); URLConnection uri = url.openConnection(); InputStream is = uri.getInputStream(); // 获取数据流 // 写入数据流 OutputStream os = new FileOutputStream(new File("E://imgs", imageName)); byte[] buf = new byte[1024]; int len = 0; while ((len = is.read(buf)) != -1) &#123; os.write(buf, 0, len); &#125; os.close(); is.close(); &#125;&#125; JAVA基本方法主要是利用JAVA中的正则表达式匹配我们我需要的元素，然后再进行其他操作。简单、粗暴。 Jsoup方式 Jsoup 是一个 Java 的开源HTML解析器，可直接解析某个URL地址、HTML文本内容。同时提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。可以直接使用DOM或者JQuery方法和表达式取出数据。 需要下载JAR包，下载地址：点我 Jsoup API：详见：http://www.open-open.com/jsoup/ 工具类StreamTool ：将byte对象转化为String对象 1234567891011121314public class StreamTool &#123;// 将byte对象转化为String对象 public static String inToStringByByte(InputStream in) throws Exception &#123; ByteArrayOutputStream outStr = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len = 0; StringBuilder content = new StringBuilder(); while ((len = in.read(buffer)) != -1) &#123; content.append(new String(buffer, 0, len, "UTF-8")); &#125; outStr.close(); return content.toString(); &#125;&#125; 基本实现类Reptile 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Reptile &#123; public static String doGet(String urlStr) throws Exception &#123; URL url; String html = ""; try &#123; url = new URL(urlStr); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); //伪装爬虫，不然会报403错误 connection.setRequestProperty("Accept", "text/html"); connection.setRequestProperty("Accept-Charset", "utf-8"); connection.setRequestProperty("Accept-Language", "en-US,en"); connection.setRequestProperty("User-Agent","Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.22 (KHTML, like Gecko) Chrome/25.0.1364.160 Safari/537.22"); connection.setRequestMethod("GET"); // 定义请求方式 connection.setConnectTimeout(5000); connection.setDoInput(true); //设置是否向httpUrlConnection输出， 默认情况下是false; connection.setDoOutput(true); // 设置是否从httpUrlConnection读入，默认情况下是true; if (connection.getResponseCode() == 200) &#123; //连接成功 System.out.println("已连接，正在解析。。。。。。"); InputStream in = connection.getInputStream(); html = StreamTool.inToStringByByte(in); &#125; else &#123; System.out.println(connection.getResponseCode()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); throw new Exception("get请求失败"); &#125; return html; &#125; public static void main(String[] args) throws Exception &#123; URL url ; InputStream is = null; OutputStream os = null; String urlStr = "https://www.baidu.com/home/news/data/newspage?nid=7953839918275534&amp;n_type=0&amp;p_from=1"; String htmlStr = Reptile.doGet(urlStr); Document doc = Jsoup.parse(htmlStr); // 将获取的网页 HTML 源代码转化为 Document对象 File f = new File("E://imgs"); //把文件存在E://imgs if (!f.exists()) &#123; f.mkdirs(); &#125; Elements pngs = doc.select("img[src]"); //获取所有图片// Elements pngs = doc.select("img[src$=.png]");只爬取png图片 int i = 1; //计数 for (Element e : pngs) &#123; String src = e.attr("src"); // 获取img中的src路径 String imageName = src.substring(src.lastIndexOf("/") + 1, src.length()); // 获取后缀名 System.out.println("正在下载第" + i + "张图片："+ imageName); URL url = new URL(src); // 连接url URLConnection uri = url.openConnection(); is = uri.getInputStream(); // 获取数据流 os = new FileOutputStream(new File("E://imgs",imageName));// 写入数据流 byte[] buf = new byte[1024]; int len = 0; while ((len = is.read(buf)) != -1) &#123; os.write(buf, 0, len); &#125; i++; &#125; os.close(); is.close(); System.out.println("共有" + (i-1) + "张图片。"); &#125;&#125; 总结在这里只做个一个简单的爬虫示例，通过两种方式的比较后，发现Jsoup更佳。 JAVA基本的方式能用正则表达式来匹配所需要的元素，灵活性不高。 Jsoup这个强大的工具提供了DOM和JQuery方法，可以直接操作节点，同时也支持正则表达式，更加的灵活、省力，同时选择性、可玩性和扩展性更高。Jsoup更多的方法可以查看Jsoup的API。 现在已经有很多开源的爬虫的框架供我们选择，比如webmagic、Heritrix等，可以适当选择。 附还有一种更为简单强大的方式，在Linux环境下，利用wget命令只需要一行命令就可以实现以上功能。 1wget -m -H -nd -l 1 -t 1 -A .jpg,.png,.jpeg,.JPEG -e robots=off -P /opt/download --no-check-certificate https://www.baidu.com/home/news/data/newspage?nid=7953839918275534&amp;n_type=0&amp;p_from=1 在下篇博客写一下Linux的基本命令。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JAVA定时调度 Timer和Executors]]></title>
      <url>%2F2017%2F03%2F27%2FJAVA%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6-Timer%E5%92%8CExecutors%2F</url>
      <content type="text"><![CDATA[近期在公司做了一个关于定时执行任务的功能（没有使用框架定时），查了一下资料，有Thread、Timer和Executors三种方法，之前使用的是Timer，但是详细查了资料觉得Executors更优，所以在这里比较一下它们的区别。 Thread类这是最基本的，创建一个Thread，然后让它在while循环里一直运行着，通过sleep方法来达到定时任务的效果。这样可以快速简单的实现，代码如下： 12345678910111213141516171819202122public class Task1 &#123; public static void main(String[] args) &#123; // run in a second final long timeInterval = 1000; Runnable runnable = new Runnable() &#123; public void run() &#123; while (true) &#123; // ------- code for task to run System.out.println("Hello !!"); // ------- ends here try &#123; Thread.sleep(timeInterval); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; Thread thread = new Thread(runnable); thread.start(); &#125; &#125; Thread的做定时任务的几率不大，因为不可控制启动停止时间、不能指定想要的delay时间。 Timer类 于第一种方式相比，优势 : (1) 当启动和去取消任务时可以控制 ; (2) 第一次执行任务时可以指定你想要的delay时间。 在实现时，Timer类可以调度任务，TimerTask则是通过在run()方法里实现具体任务。 Timer实例可以调度多任务，它是线程安全的。 当Timer的构造器被调用时，它创建了一个线程，这个线程可以用来调度任务。 12345678910111213141516public class Task2 &#123; public static void main(String[] args) &#123; TimerTask task = new TimerTask() &#123; @Override public void run() &#123; // task to run goes here System.out.println("Hello !!!"); &#125; &#125;; Timer timer = new Timer(); long delay = 0; long intevalPeriod = 1 * 1000; // schedules the task to be run in an interval timer.scheduleAtFixedRate(task, delay, intevalPeriod); &#125; // end of main &#125; 缺点：如果TimerTask抛出未检查的异常，Timer将会产生无法预料的行为。Timer线程并不捕获异常，所以 TimerTask抛出的未检查的异常会终止timer线程。这种情况下，Timer也不会再重新恢复线程的执行了;它错误的认为整个Timer都被取消了。此时，已经被安排但尚未执行的TimerTask永远不会再执行了，新的任务也不能被调度了。 Executors ScheduledExecutorService是从Java SE5的java.util.concurrent里，做为并发工具类被引进的，这是最理想的定时任务实现方式。 相比于上两个方法，它有以下好处 : (1) 相比于Timer的单线程，它是通过线程池的方式来执行任务的 ; (2) 可以很灵活的去设定第一次执行任务delay时间 ; (3) 提供了良好的约定，以便设定执行的时间间隔 。 下面是实现代码，我们通过ScheduledExecutorService展示这个例子，通过代码里参数的控制，首次执行加了delay时间。 1234567891011121314public class Task3 &#123; public static void main(String[] args) &#123; Runnable runnable = new Runnable() &#123; public void run() &#123; // task to run goes here System.out.println("Hello !!"); &#125; &#125;; ScheduledExecutorService service = Executors .newSingleThreadScheduledExecutor(); // 第二个参数为首次执行的延时时间，第三个参数为定时执行的间隔时间 service.scheduleAtFixedRate(runnable, 10, 1, TimeUnit.SECONDS); &#125; &#125; 线程池能按时间计划来执行任务，允许用户设定计划执行任务的时间。 当任务较多时，线程池可能会自动创建更多的工作线程来执行任务 。 支持多个任务并发执行。 总结Timer是单线程的。所以task都是串行执行。假如其中一个task执行需要很长的时间，那其他的task只能干巴巴的等着。 ScheduledThreadPoolExecutor是一个可以重复执行任务的线程池，并且可以指定任务的间隔和延迟时间。它作为比Timer/TimerTask更加通用的替代品。因为它允许多个服务线程，接受不同的时间单位，且不需要继承TimeTask（仅仅需要实现Runnable接口）。配置ScheduledThreadPoolExecutor为单线程，则与使用Timer等效。 上述，基本说明了在以后的开发中尽可能使用ScheduledExecutorService(JDK1.5以后)替代Timer。 下面是自己做的功能，通过短信API定时查询教师回复信息并更新数据库。 123456789101112131415161718192021222324252627282930/** * 定时查询教师回复状态 * @param a */public void getStatusSchedule(final Date replyEnd)&#123; final SendMessage sendMsg = new SendMessage(); final ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor(); service.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; try &#123; Date nowDate = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()));//当前时间 //若截至时间在当前时间之前执行定时任务 否则不执行 if (!nowDate.before(replyEnd)) &#123; service.shutdown(); //停止任务 return; &#125;else &#123; Map&lt;String,Object&gt; map = sendMsg.getReplyMsg(); //获取回复信息 if(!map.isEmpty())&#123; //当map不为空时执行 updateMsgStatus(map); //更新数据库 &#125; &#125; &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, 1, 1, TimeUnit.MINUTES); //执行后第一次查询在1分钟之后，每隔1分钟查询一次。 &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈共享单车]]></title>
      <url>%2F2017%2F03%2F24%2F%E6%B5%85%E8%B0%88%E5%85%B1%E4%BA%AB%E5%8D%95%E8%BD%A6%2F</url>
      <content type="text"><![CDATA[​ 要说目前最火爆的互联网现象，当属共享单车。这里所谓的共享，本质上指的是需求共享。就骑车的需求，从一个地方骑到另一个地方，就是用户触点（产品投放）、产品操作（骑行过程）、付费模式（支付）的流程，从个体上来讲，这个流程是单向的。但在“共享”的模式下，扫码骑走，停车即走，把不同的人，在不同的时间和地点，相同的骑行需求，通过产品操作节点，形成需求闭环，停车点同时又是骑行出发点，这就是需求共享。 共享单车是指企业与政府合作，在地铁、学校、公交站点、居民区、商业区、公共服务区等提供自行车单车共享服务，是共享经济的一种新形态。 ​ 2016年底以来，国内共享单车突然就火爆了起来，而在街头，仿佛一夜之间，共享单车已经到了“泛滥”的地步，各大城市路边排满各种颜色的共享单车。 场景分析​ 我们站在用户角度，无非就是找车，然后骑车，交钱。 在“寻车-用车-骑车-还车”的场景闭环中，需要考虑的问题有很多，列举以下若干种： 什么样的寻车方式更符合大众的日常行为？ 用户与单车之间如何建立一一对应的联系？ 使用何种开锁构件实现远程开锁和上锁？ 计费方式及费用节点、价格、操作流程分别采取什么方案？ 如何对车辆进行远程管理？ 如何防止逃费、盗窃、破坏等衍生问题？ 场景分析的过程，就是解决以上若干问题的过程，针对这些问题，分别提出不同的业务流程和技术方案。 业务逻辑分析以摩拜单车为例，用户-管理平台-单车 之间的关系如下图: 技术实现方案​ 现在共享单车最火的要数摩拜单车和OFO小黄车了，摩拜采用智能锁而ofo采用的是机械锁。 1 机械锁​ 原理：机械锁的原理很简单，只需要打开软件，输入对应的车牌号就可以了，其实就是后台查询数据库，判断单车是否处于正常状态，返回给用户开锁密码，用户拿着开锁密码开锁。 2 智能锁​ 原理：对于单车的远程开锁机制，采用远程通信控制机械构件的电磁运动来实现。远程通信可采用传统的SIM卡通信的方式。 一、手机扫描自行车，获得自行车唯一的ID标志，手机接着会像服务器提交一个请求（提交信息里包含：用户信息，请求动作，车辆ID）；二、服务器收到用户开锁请求，此时会根据请求信息，接着向指定ID的自行车发出开锁指令;三、自行车收到服务器请求，会执行相应的开锁动作。 智能锁是耗费电能的，所以摩拜单车车篮中装有太阳能电池板，减少人力物力维护的成本、简单、高效。 ​ 这是一个典型的大容量互联网O2O场景，连结用户、车辆，管理平台进行实时处理效率要求非常高，需制定可靠、高效的网络方案。根据业务流程，我们梳理出网络节点的职能，并从成本考虑使用最优方案： ​ 明确流程，界面，那么接下来的任务就是通过用户语言去实现产品流程了，即界面设计与开发实现，这里我们就不阐述了。 一点感想​ 从2016年到现在已有近半年时间，共享单车的竞争也愈演愈烈，近几天，共享单车从免费到红包“撒钱” 导致竞争升级，共享单车方便了我们的出行，但是带来的问题也很多，政府也在不断的规范使用。现在都在处于资本投入和烧钱大战中，希望共享单车一直存货下去，同时希望大家能合理、合法使用。 之前有听说过摩拜的扫一扫可以远程使用，假如我需要车又没有注册，我可以拍照给有车的朋友，让他们帮我远程扫就可以开启，亲测：不行！还是自己乖乖注册一个吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown语法指南]]></title>
      <url>%2F2017%2F03%2F21%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[花了一段时间把自己的个人博客搭建好了，但是博客必须是要用Markdown书写，所以查了一下Markdown编辑器的语法，在这里做个记录。 Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown。完全采用Markdown编辑器的博客平台有Ghost和Typecho。 基本技巧1 代码如果你只想高亮语句中的某个函数名或关键字，可以使用 `function_name()` 实现 通常编辑器根据代码片段适配合适的高亮方法，但你也可以用 ``` 包裹一段代码，并指定一种语言 12345​```javascript$(document).ready(function () &#123; alert('hello world');&#125;);​``` 支持的语言：actionscript, apache, bash, clojure, cmake, coffeescript, cpp, cs, css, d, delphi, django, erlang, go, haskell, html, http, ini, java, javascript, json, lisp, lua, markdown, matlab, nginx, objectivec, perl, php, python, r, ruby, scala, smalltalk, sql, tex, vbscript, xml 也可以使用 4 空格缩进，再贴上代码，实现相同的的效果 123 def g(x): yield from range(x, 0, -1) yield from range(x) 2 标题文章内容较多时，可以用标题分段： 12345678标题1======标题2-----## 大标题 ##### 小标题 ### 3 粗斜体123*斜体文本* _斜体文本_**粗体文本** __粗体文本__***粗斜体文本*** ___粗斜体文本___ 4 链接4.1 常用链接方法 12文字链接 ![链接名称](http://链接网址)网址链接 &lt;http://链接网址&gt; 4.2 高级链接技巧 123456这个链接用 1 作为网址变量 [Google][1].这个链接用 yahoo 作为网址变量 [Yahoo!][yahoo].然后在文档的结尾为变量赋值（网址） [1]: http://www.google.com/ [yahoo]: http://www.yahoo.com/ 5 列表5.1 普通无序列表 123- 列表文本前使用 [减号+空格]+ 列表文本前使用 [加号+空格]* 列表文本前使用 [星号+空格] 5.2 普通有序列表 1231. 列表前使用 [数字+空格]2. 我们会自动帮你添加数字7. 不用担心数字不对，显示的时候我们会自动把这行的 7 纠正为 3 5.3 列表嵌套 12345678910111213141516171. 列出所有元素： - 无序列表元素 A 1. 元素 A 的有序子列表 - 前面加四个空格2. 列表里的多段换行： 前面必须加四个空格， 这样换行，整体的格式不会乱3. 列表里引用： &gt; 前面空一行 &gt; 仍然需要在 &gt; 前面加四个空格4. 列表里代码段：前面四个空格，之后按代码语法 ``` 书写​``` 或者直接空八个，引入代码块 6 引用6.1 普通引用 12&gt; 引用文本前使用 [大于号+空格]&gt; 折行可以不加，新起一行都要加上哦 6.2 引用里嵌套引用 123&gt; 最外层引用&gt; &gt; 多一个 &gt; 嵌套一层引用&gt; &gt; &gt; 可以嵌套很多层 6.3 引用里嵌套列表 123&gt; - 这是引用里嵌套的一个列表&gt; - 还可以有子列表&gt; * 子列表需要从 - 之后延后四个空格开始 6.4 引用里嵌套代码块 12345&gt; 同样的，在前面加四个空格形成代码块&gt; &gt; &gt; 或者使用 ``` 形成代码块&gt; `` 7 图片7.1 跟链接的方法区别在于前面加了个感叹号 !，这样是不是觉得好记多了呢？ 1![图片名称](http://图片网址) 7.2 当然，你也可以像网址那样对图片网址使用变量 1234这个链接用 1 作为网址变量 [Google][1].然后在文档的结尾位变量赋值（网址） [1]: http://www.google.com/logo.png 也可以使用 HTML 的图片语法来自定义图片的宽高大小 1&lt;img src="htt://example.com/sample.png" width="400" height="100"&gt; 8 换行如果另起一行，只需在当前行结尾加 2 个空格 12在当前行的结尾加 2 个空格 这行就会新起一行 如果是要起一个新段落，只需要空出一行即可。 9 分隔符如果你有写分割线的习惯，可以新起一行输入三个减号-。当前后都有段落时，请空出一行： 12345前面的段落---后面的段落 高级技巧1 行内 HTML 元素目前只支持部分段内 HTML 元素效果，包括 ，如 键位显示 1使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑 代码块 1使用 &lt;pre&gt;&lt;/pre&gt; 元素同样可以形成代码块 粗斜体 1&lt;b&gt; Markdown 在此处同样适用，如 *加粗* &lt;/b&gt; 2 符号转义如果你的描述中需要用到 markdown 的符号，比如 _ # * 等，但又不想它被转义，这时候可以在这些符号前加反斜杠，如 \_ \#``\* 进行避免。 12\_不想这里的文本变斜体\_\*\*不想这里的文本被加粗\*\* 3 扩展支持 jsfiddle、gist、runjs、优酷视频，直接填写 url，在其之后会自动添加预览点击会展开相关内容。 1234http://&#123;url_of_the_fiddle&#125;/embedded/[&#123;tabs&#125;/[&#123;style&#125;]]/https://gist.github.com/&#123;gist_id&#125;http://runjs.cn/detail/&#123;id&#125;http://v.youku.com/v_show/id_&#123;video_id&#125;.html 4 公式当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如： 12345$$ x = &#123;-b \pm \sqrt&#123;b^2-4ac&#125; \over 2a&#125;. $$$$x \href&#123;why-equal.html&#125;&#123;=&#125; y^2 + 1$$ 同时也支持 HTML 属性，如： 12345$$ (x+1)^2 = \class&#123;hidden&#125;&#123;(x+1)(x+1)&#125; $$$$(x+1)^2 = \cssId&#123;step1&#125;&#123;\style&#123;visibility:hidden&#125;&#123;(x+1)(x+1)&#125;&#125;$$ 总结markdown语法写多了自然就会了，网上有很多markdown语法编辑器，比如有道云、马克飞象、Typora等。我目前使用的是Typora编辑器，使用起来比其他的更简单、舒适，方便。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[博客建成第一天]]></title>
      <url>%2F2017%2F03%2F07%2F%E5%8D%9A%E5%AE%A2%E5%BB%BA%E6%88%90%E7%AC%AC%E4%B8%80%E5%A4%A9%2F</url>
      <content type="text"><![CDATA[经过几天的努力，自己的博客终于搭建起来了，打心里很开心。 这不是贴吧，不是豆瓣，不是CSDN，这是我自己在互联网上的一小点领地。 从开始博客基本样式，到域名，自己一步一步摸索搭建起来的，我相信自己可以做的更好，加油!]]></content>
    </entry>

    
  
  
</search>
