---
title: JVM类加载机制
date: 2017-12-13 10:03:36
tags: [java, jvm]
categories: 后端
---

# 引言

之前的博客说了Java虚拟机的运行时数据区域、GC算法、垃圾回收器等知识。距离深入了解还有一段距离，包括虚拟机的类加载机制、性能调优、线程并发等等还都没有涉及到，一直在看周志明的《深入理解Java虚拟机》，越深入去读发现这本书写的真的是经典，解决了自己很多的疑惑。

JVM的类加载机制。虚拟机把描述类的数据从class文件加载到内存中，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。<div align=center><img width="700" height="300" src="../../../../images/2017/12/ClassLoader/0.png" algin="center"/>

</div><!-- more -->

# 类加载过程

类被加载到虚拟机内存中开始，到卸载出内存为止。它的生命周期分7个阶段，加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）、卸载（Unloading）。其中验证、准备、解析三个部分统称为连接（Linking）。

<div align=center><img width="700" height="300" src="../../../../images/2017/12/ClassLoader/2.png" algin="center"/>

</div>

## 加载

1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。

```java
注意：JVM中的ClassLoader类加载器加载Class发生在此阶段。后面会有描述。
```

## 连接

### 验证

验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：`文件格式的验证`、`元数据的验证`、`字节码验证`和`符号引用验证`。

#### 文件格式验证

1. 主要验证字节流是否符合calss文件格式的规范，如果符合则把字节流加载到方法区中进行存储。
2. 验证文件头、主次版本等等。

#### 元数据验证

主要对字节码描述的信息进行语义分析，保证其描述符合Java语言的要求。

1. 类是否有父类。
2. 是否继承了不允许被继承的类（final修饰过的类）。
3. 如果这个类不是抽象类，是否实现其父类或接口中所有要求实现的方法。
4. 类中的字段、方法是否与父类产生矛盾（如：覆盖父类final类型的字段，或者不符合个则的方法）。

#### 字节码验证

该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。
保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。

#### 符号引用验证

1. 符号引用中通过字符串描述的全限定名是否能找到对应的类。
2. 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。
3. 符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。

### 准备

**准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。**对于该阶段有以下几点需要注意：

  1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。

​    2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。

假设一个类变量的定义为：public static int value = 3；

那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器<clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。

下表列出了Java中所有基本数据类型以及reference类型的默认零值：

<div align=center><img width="300" height="300" src="../../../../images/2017/12/ClassLoader/defaultValue.png"/>

</div>

```
注意：
只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是在对象实例化的时候初始化分配值的。
```

### 解析

**解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。**

1. 类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。
2. 字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。
3. 类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。
4. 接口方法解析：与类方法解析步骤类似，只是接口不会有父类，因此，只递归向上搜索父接口就行了。

## 初始化

初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是**根据程序员通过程序指定的主观计划去初始化类变量和其他资源**，或者可以从另一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。

1. 执行类构造器<clinit>。
2. 初始化静态变量、静态块中的数据等（一个类加载器只会初始化一次）。
3. 子类的<clinit>调用前保证父类的<clinit>被调用。

```java
注意：
<clinit>是线程安全的，执行<clinit>的线程需要先获取锁才能进行初始化操作，保证只有一个线程能执行<clinit>(利用此特性可以实现线程安全的懒汉单例模式)。如果在一个类的<clinit>方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。
```

# 类加载器

类被加载进虚拟机是由类加载器（ClassLoader）来完成的。类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类的加载阶段。对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在就Java虚拟机中的唯一性，也就是说，即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的Class对象的equals（）、isAssignableFrom（）、isInstance（）等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果。只有在两个类被**同一个类加载器**加载的前提下，比较才有意义。否则，即使两个类来自同一个class文件，被同一个JVM加载，但是加载它们的类加载器不同，则这两个类就不相等。这就相当于两个命名空间中的等价类`LoaderA::C`和`LoaderB::C`。

## 类加载器的种类

从Java虚拟机的角度来分的话，ClassLoader分为启动类加载器（Bootstrap ClassLoader）和其它的加载器。其中Bootstrap ClassLoader负责加载Java的核心类，该类加载器使用C++语言实现，属于虚拟机自身的一部分。而其它类加载器独立于JVM外部，并且全部继承自抽象类java.lang.ClassLoader。

站在Java开发人员的角度来分的话，ClassLoader分为：

- **启动类加载器（Bootstrap ClassLoader）**

  负责加载`JAVA_HOME\lib`目录中并且能被虚拟机识别的类库到JVM内存中（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载），如果名称不符合的类库即使放在lib目录中也不会被加载。该类加载器无法被Java程序直接引用。

- **扩展类加载器（Extension ClassLoader）**

  该加载器主要是负责加载`JDK\jre\lib\ext`目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类）。该加载器可以被开发者直接使用。

- **应用程序类加载器（Application ClassLoader）**

  该类加载器也称为系统类加载器（System ClassLoader），它负责加载用户类路径（Classpath）上所指定的类库，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，`一般情况下这个就是程序中默认的类加载器`。

除此之外，还有自定义的类加载器，它们之间的层次关系被称为类加载器的**双亲委派模型**。该模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，而这种父子关系一般通过**组合（Composition）关系**来实现，而不是通过继承（Inheritance）。

# 双亲委派模型

<div align=center><img width="700" height="300" src="../../../../images/2017/12/ClassLoader/3.jpg" algin="center"/>

</div>

如上图所示的类加载器之间的这种层次关系，就称为**类加载器的双亲委派模型**（Parent Delegation Model）。该模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过组合（Composition）关系来复用父加载器的代码。

双亲委派模型的工作过程为：**如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载**。

   使用这种模型来组织类加载器之间的关系的好处是Java类随着它的类加载器一起**具备了一种带有优先级的层次关系**。例如java.lang.Object类，无论哪个类加载器去加载该类，最终都是由启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。否则的话，如果不使用该模型的话，如果用户自定义一个java.lang.Object类且存放在classpath中，那么系统中将会出现多个Object类，应用程序也会变得很混乱。如果我们自定义一个rt.jar中已有类的同名Java类，会发现JVM可以正常编译，但该类永远无法被加载运行。

   在rt.jar包中的java.lang.ClassLoader类中，我们可以查看类加载实现过程的代码，具体源码如下：

```java
protected synchronized Class<?> loadClass(String name, boolean resolve)   throws ClassNotFoundException{  
    // First, check if the class has already been loaded  
    //首先检查请求的类是否已经被加载过   
    Class c = findLoadedClass(name);  
    if (c == null) {  
        try {  
          	//委派父类加载器加载  
            if (parent != null) {  
                c = parent.loadClass(name, false);
            //委派启动类加载器加载  
            } else {  
                c = findBootstrapClassOrNull(name);  
            }  
        //父类加载器无法完成类加载请求   
        } catch (ClassNotFoundException e) {  
            // ClassNotFoundException thrown if class not found  
            // from the non-null parent class loader  
        }  
       	//本身类加载器进行类加载
        if (c == null) {  
            // If still not found, then invoke findClass in order  
            // to find the class.  
            c = findClass(name);  
        }  
    }  
    if (resolve) {  
        resolveClass(c);  
    }  
    return c;  
}  
```

通过上面代码可以看出，双亲委派模型是通过loadClass()方法来实现的，根据代码以及代码中的注释可以很清楚地了解整个过程其实非常简单：先检查是否已经被加载过，如果没有则调用父加载器的loadClass()方法，如果父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载器加载失败，则先抛出ClassNotFoundException，然后再调用自己的findClass()方法进行加载。

注意，双亲委派模型是Java设计者推荐给开发者的类加载器的实现方式，并不是强制规定的。大多数的类加载器都遵循这个模型，但是JDK中也有较大规模破坏双亲模型的情况，例如线程上下文类加载器（Thread Context ClassLoader）的出现。

# 总结

整个类加载过程中，除了在加载阶段用户应用程序可以自定义类加载器参与之外，其余所有的动作完全由虚拟机主导和控制。到了初始化才开始执行类中定义的Java程序代码，但这里的执行代码只是个开端，它仅限于<clinit>（）方法。类加载过程中主要是将Class文件（准确地讲，应该是类的二进制字节流）加载到虚拟机内存中，真正执行字节码的操作，在加载完成后才真正开始。