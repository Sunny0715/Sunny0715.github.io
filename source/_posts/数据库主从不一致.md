---
title: 数据库主从不一致
date: 2018-07-08 21:21:13
tags: [mysql]
categories: 后端
---

# 引言

在开发过程中，进场遇到数据库主从分离来降低读写的压力，但是数据库主从同步是有延时的，这里聊一聊数据库主库与从库的一致性问题。<div align=center><img width="700" height="300" src="../../../../images/2018-7/%E4%B8%BB%E4%BB%8E%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/index.png" algin="center"/>

</div><!-- more -->

# 常见的数据库集群架构

**一主多从，主从同步，读写分离**

<div align=center><img width="1000" height="300" src="../../../../images/2018-7/%E4%B8%BB%E4%BB%8E%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/1.png" algin="center"/></div>

如上图所示

- 一个主库提供写服务
- 多个从库提供读服务，可以增加从库提升读性能
- 主从之间同步

> 任何方案不要忘了本心，增加从库的本心是提升读性能

# 为什么会出现不一致

**主从同步有时延**，这个时延期间读从库，可能读到不一致的数据。

<div align=center><img width="1000" height="300" src="../../../../images/2018-7/%E4%B8%BB%E4%BB%8E%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/2.png" algin="center"/></div>

如上图

1. 服务发齐了一个写请求
2. 服务又发起了一个读请求，此时同步未完成，读到一个不一致的脏数据
3. 数据库主从同步最后才完成

> 任何数据冗余，必将引发一致性问题。

# 解决方法

## 忽略

任何脱离业务的架构设计都是耍流氓，绝大部分业务，例如：百度搜索，淘宝订单，QQ消息，58帖子都允许短时间不一致。

> 如果业务能接受，最推崇此法。

**如果业务能够接受，别把系统架构搞得太复杂。**

## 强制读主

<div align=center><img width="1000" height="300" src="../../../../images/2018-7/%E4%B8%BB%E4%BB%8E%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/3.png" algin="center"/></div>

如上图

1. 使用一个**高可用主库**提供数据库服务
2. 读和写都落到主库上
3. 采用**缓存来提升系统读性能**

这是很常见的微服务架构，可以避免数据库主从一致性问题。

## 选择性读主

强制读主过于粗暴，毕竟只有少量写请求，很短时间，可能读取到脏数据。

有没有可能实现，**只有这一段时间，可能读到从库脏数据的读请求读主**，平时读从呢？

可以利用一个缓存记录必须读主的数据。

<div align=center><img width="1000" height="300" src="../../../../images/2018-7/%E4%B8%BB%E4%BB%8E%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/4.png" algin="center"/></div>

如上图，当写请求发生时：

1. 写主库
2. 将哪个库，哪个表，哪个主键三个信息拼装一个key设置到cache里，这条记录的超时时间，设置为“主从同步时延”

> key的格式为“db:table:PK”，假设主从延时为1s，这个key的cache超时时间也为1s。

<div align=center><img width="1000" height="300" src="../../../../images/2018-7/%E4%B8%BB%E4%BB%8E%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/5.png" algin="center"/></div>

如上图，当读请求发生时：

这是要读哪个库，哪个表，哪个主键的数据呢，也将这三个信息拼装一个key，到cache里去查询，如果：

1. **cache里有这个key**，说明1s内刚发生过写请求，数据库主从同步可能还没有完成，此时就应该**去主库查询**。
2. **cache里没有这个key**，说明最近没有发生过写请求，此时就可以**去从库查询**。

以此，保证读到的一定不是不一致的脏数据。

# 总结

数据库主库和从库不一致，常见有这么几种优化方案：

1. 业务可以接受，系统不优化；
2. 强制读主，高可用主库，用缓存提高读性能；
3. 在cache里记录哪些记录发生过写请求，来路由读主还是读从。